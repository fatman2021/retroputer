# Reading the Keyboard

The keyboard device exposes information about the state of the keyboard at three ports: 0x10â€“0x12. Each port returns a different piece of information about the state of the keyboard.

## Key presses \(0x10\)

Port 0x10 can be queried to return the first key stored in the keyboard's 32-character buffer. Upon being read, the buffer is immediately shifted.

> **Note**: recent key presses are not discarded when the buffer fills up. Instead, the earliest key presses are discarded. As such, it is important to ensure that the keyboard buffer is frequently read if you don't wish to lose older keystrokes.

> **Note**: if there are no keys in the buffer, the Exception flag will be set.

Keys, if held down, will be repeated based upon the host OS's settings.

Most keystrokes will result in an ASCII-like symbol. For example, if the user strikes the letter "A" with SHIFT held down, reading port 0x10 will return 65 \("A"\). If SHIFT was not held down, the same keystroke would return 97 \("a"\).

The lower 32 symbols, however, represent control characters and are generated by certain keystrokes. You can use these to detect TAB, BACKSPACE, ENTER, and others, as follows:

| Keystroke | JavaScript | RetSCII | Keystroke | JavaScript | RetSCII |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Page Up** | 33 | 1 | **F1** | 112 | 16 |
| **Page Down** | 34 | 2 | **F2** | 113 | 17 |
| **End** | 35 | 3 | **F3** | 114 | 18 |
| **Home** | 36 | 4 | **F4** | 115 | 19 |
| **Left** | 37 | 5 | **F5** | 116 | 20 |
| **Up** | 38 | 6 | **F6** | 117 | 21 |
| **Right** | 39 | 7 | **F7** | 118 | 22 |
| **Down** | 40 | 10 | **F8** | 119 | 23 |
| **Backspace** | 8 | 8 | **F9** | 120 | 24 |
| **Tab** | 9 | 9 | **F10** | 121 | 25 |
| **Enter** | 13 | 13 | **F11** | 122 | 26 |
| **Insert** | 45 | 11 | **F12** | 123 | 27 |
| **Delete** | 46 | 12 | | | |

If you're reading the keyboard directly, you can easily determine how to react by checking if the key code is less than 32, like so:

```
init:
    LDI A, 32
    MOV B, A
readkey:
    IN A, 0x10                      ; read key into A
    IF E
        BR :read-key                ; no key pressed;
    CMP A, B
    IF N                            ; if key code is < 32
        BR :handle-control-key      ; it's a control key
handle-normal-key:
    ...
    BR :readkey
handle-control-key:
    ...
    BR :readkey
```

## Modifier Key State \(0x11\)

It is also possible to read the state of the various modifier keys on the keyboard using port 0x11. The return value is a bitmap representing the state of seven keys at that point in time where a bit being set represents that the respective key is being pressed. No buffer is maintained for these values.

| MSB, 7 | 6 | 5 | 4 | 3 | 2 | 1 | LSB, 0 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| SHIFT | CTRL | ALT | BREAK | NUM LOCK | SCROLL LOCK | CAPS LOCK | - |

## Directional Key State \(0x12\)

Games often use the keyboard to determine how to move a character or perform some other action. As such, it is handy to have access to the directional keys in a manner that doesn't rely on keyboard buffering. Port 0x12 returns a bitmap representing the state of the directional keys without any buffering.

| 3 | 2 | 1 | 0 |
| :--- | :--- | :--- | :--- |
| Up | Left | Right | Down |

The arrow keys on the keyboard \(UP, LEFT, RIGHT, DOWN\) correspond directly with the bits above. If additional directional keys are pressed, they will also be represented \(for example, UP + LEFT will have bits 3 and 2 set\).

Other keys can also directly correspond to these bits. The W, A, S, and D keys are mapped to Up, Left, Down, and Right, respectively.

The Home, Page Up, Page Down, and End keys map to directions in the following manner:

| Key | Direction |
| :--- | :--- |
| Home | Up & Left |
| Page Up | Up & Right |
| Page Down | Down & Right |
| End | Down & Left |


